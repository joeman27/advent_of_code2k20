{"message":"type annotations needed","code":{"code":"E0284","explanation":"This error occurs when the compiler is unable to unambiguously infer the\nreturn type of a function or method which is generic on return type, such\nas the `collect` method for `Iterator`s.\n\nFor example:\n\n```compile_fail,E0284\nfn foo() -> Result<bool, ()> {\n    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n    let v: Vec<bool> = results.collect()?;\n    // Do things with v...\n    Ok(true)\n}\n```\n\nHere we have an iterator `results` over `Result<bool, ()>`.\nHence, `results.collect()` can return any type implementing\n`FromIterator<Result<bool, ()>>`. On the other hand, the\n`?` operator can accept any type implementing `Try`.\n\nThe author of this code probably wants `collect()` to return a\n`Result<Vec<bool>, ()>`, but the compiler can't be sure\nthat there isn't another type `T` implementing both `Try` and\n`FromIterator<Result<bool, ()>>` in scope such that\n`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\nis returned.\n\nTo resolve this error, use a concrete type for the intermediate expression:\n\n```\nfn foo() -> Result<bool, ()> {\n    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n    let v = {\n        let temp: Result<Vec<bool>, ()> = results.collect();\n        temp?\n    };\n    // Do things with v...\n    Ok(true)\n}\n```\n\nNote that the type of `v` can now be inferred from the type of `temp`.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":223,"byte_end":228,"line_start":10,"line_end":10,"column_start":21,"column_end":26,"is_primary":true,"text":[{"text":"            if line.parse().unwrap() == line2.parse().unwrap(){","highlight_start":21,"highlight_end":26}],"label":"cannot infer type for type parameter `F` declared on the associated function `parse`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `<_ as FromStr>::Err == _`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the type argument in the method call","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":228,"byte_end":228,"line_start":10,"line_end":10,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            if line.parse().unwrap() == line2.parse().unwrap(){","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"::<F>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0284]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:10:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if line.parse().unwrap() == line2.parse().unwrap(){\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type for type parameter `F` declared on the associated function `parse`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: cannot satisfy `<_ as FromStr>::Err == _`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider specifying the type argument in the method call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if line.parse::<F>().unwrap() == line2.parse().unwrap(){\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0284`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0284`.\u001b[0m\n"}
